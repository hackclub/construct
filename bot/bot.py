from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler
import os
import re
import requests
import certifi
from dotenv import load_dotenv
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
import importlib
import importlib.util
ai_helpers_mod = None
try:
    ai_helpers_mod = importlib.import_module("bot.ai_helpers")
except Exception:
    try:
        ai_helpers_path = Path(__file__).resolve().parent / "ai_helpers.py"
        spec = importlib.util.spec_from_file_location("bot.ai_helpers", str(ai_helpers_path))
        ai_helpers_mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(ai_helpers_mod)
    except Exception as e:
        raise SystemExit("Cannot import ai_helpers module: " + str(e))
read_faq = ai_helpers_mod.read_faq
local_validate = ai_helpers_mod.local_validate
os.environ.setdefault("SSL_CERT_FILE", certifi.where())
load_dotenv(Path(__file__).resolve().parents[1] / ".env")

bot_token = os.environ.get("SLACK_BOT_TOKEN")
app_token = os.environ.get("SLACK_APP_TOKEN")
api_key = os.environ.get("AI_API_KEY")
api_base = os.environ.get("AI_API_BASE", "https://api.example.com")
api_model = os.environ.get("AI_MODEL", "qwen/qwen3-32b")
bot_name = os.environ.get("BOT_NAME", "Assistant")
faq_link = os.environ.get("FAQ_LINK", "").strip()
validation_model = os.environ.get("AI_VALIDATION_MODEL", "x-ai/grok-4.1-fast")
max_retries = int(os.environ.get("AI_MAX_RETRIES", "2"))
listen_env = os.environ.get("LISTEN_CHANNEL_ID", "")
if not listen_env:
    try:
        listen_env = input("Enter channel ID to listen to (comma-separated for multiple, leave empty for all): ").strip()
    except Exception:
        listen_env = ""
if listen_env:
    listen_channels = [c.strip() for c in listen_env.split(",") if c.strip()]
else:
    listen_channels = []
if not bot_token or not app_token:
    raise SystemExit("Missing SLACK_BOT_TOKEN or SLACK_APP_TOKEN")
if not api_key:
    raise SystemExit("Missing AI_API_KEY")
app = App(token=bot_token)
formatting_instructions = """
### Slack formatting summary

*Bold*
Use asterisks around text to bold: `*bold text*` â†’ *bold text*

_Italic_
Use underscores to italicize: `_italic_` â†’ _italic_

~Strikethrough~
Use tildes to strike through: `~text~` â†’ ~text~

*Bold + Italic*
Wrap with `*_` and `_*` pair: `*_both_*` â†’ *_both_*

Inline code
Surround with a single backtick: `` `inline code` `` â†’ `inline code`

Code blocks
Fenced code block using triple backticks for multi-line snippets:
```
```python
def example():
    return True
```
```

Blockquotes
Start lines with `>` to create block quotes:
`> This is a quote` â†’
> This is a quote

Lists
Bullet list:
```
- item one
- item two
```

Numbered list:
```
1. First
2. Second
```

Links
Custom label: `<https://example.com|label>` â†’ <https://example.com|label>

Emoji
Use names in colons: `:smile:` â†’ ðŸ˜„

Note about disclaimers
Every reply produced by the model must include a one-line source disclaimer stating the FAQ source and that the information may be incomplete. The precise AI-autogenerated-disclaimer (e.g. 'This reply was generated by an AI...') will be added later and should not be inserted by the model.
"""

faq_source_text = f"{faq_link}" if faq_link else "the provided FAQ document"
check_system = (
    f"You are {bot_name}. Using ONLY the FAQ below, decide whether the FAQ contains the answer to the user's question."
    " Reply ONLY 'YES' or 'NO' and include a single short justification (one sentence)."
    " Format the reply using Slack markup per the guide and do not add any extra text."
    "\n\nFormatting rules:\n" + formatting_instructions
)
answer_system = (
    f"You are {bot_name}, a friendly assistant with a playful persona: a construction-worker raccoon."
    " Be friendly, slightly rough-and-ready, and a little funny â€” short quips or small metaphors are fine, but keep replies concise and professional."
    " Use ONLY the FAQ below to answer the user's question. Do NOT invent facts or add information not present in the FAQ."
    " Start the reply with a brief greeting (for example: 'Hi,' or 'Hello,'), then give a concise answer."
    " This reply should be self-contained: do NOT encourage follow-up questions, ask for more details, or prompt the user to continue the conversation."
    " The bot will only send this single reply for the message, so make it complete and final."
    " At the end, add a one-line disclaimer stating that the information was taken from the FAQ link or document and may be incomplete."
    " Do NOT include any additional AI-safety statement lines â€” the system will append the standard AI-generated disclaimer separately."
    f" Mention the source as: {faq_source_text}."
    " Also politely suggest that the user close the ticket if their question is resolved (for example: 'If this helped, please close the ticket.')."
    " IMPORTANT: You MUST output ONLY the message in the exact style described: greeting, concise answer, one-line disclaimer with the FAQ source, and the close-ticket suggestion."
    " Do not add any analysis, internal notes, or extra sections. Format using Slack markup per the guide after the FAQ."
    "\n\nFormatting rules:\n" + formatting_instructions
)

MAX_WORKERS = int(os.environ.get("AI_MAX_WORKERS", "5"))
executor = ThreadPoolExecutor(max_workers=MAX_WORKERS)
try:
    auth_resp = app.client.auth_test()
except Exception as e:
    logger = None
    try:
        pass
    except Exception:
        pass
def process_message(channel_arg, ts_arg, text_arg, client_arg, logger_arg):
    try:
        url = f"{api_base.rstrip('/')}/proxy/v1/chat/completions"
        local_path_inner = os.environ.get("LOCAL_DOCS_PATH")
        faq_text_inner = read_faq(local_path_inner)
        if not faq_text_inner:
            return
        headers_inner = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json",
        }
        check_payload_inner = {
            "model": api_model,
            "messages": [
                {"role": "system", "content": check_system + "\n\nFAQ:\n" + (faq_text_inner or "")},
                {"role": "user", "content": f"Question: {text_arg}\nDoes the FAQ above contain the answer? Reply only YES or NO and a one-line justification."}
            ],
            "stream": False,
            "temperature": 0.0,
            "max_tokens": 200,
        }
        try:
            resp = requests.post(url, headers=headers_inner, json=check_payload_inner, timeout=(15, 30))
            resp.raise_for_status()
            data = resp.json()
            choices = data.get("choices") or []
            if choices:
                check_reply_inner = choices[0].get("message", {}).get("content", "").strip()
            else:
                check_reply_inner = "NO"
        except Exception:
            return
        if not re.search(r"\bYES\b", check_reply_inner, re.IGNORECASE):
            return
        answer_payload_inner = {
            "model": api_model,
            "messages": [
                {"role": "system", "content": answer_system + "\n\nFAQ:\n" + (faq_text_inner or "") + "\n\n" + formatting_instructions},
                {"role": "user", "content": f"Question: {text_arg}\nProvide a concise answer based only on the FAQ."}
            ],
            "stream": False,
            "temperature": 0.2,
            "max_tokens": 512,
        }
        attempt_inner = 0
        final_msg_inner = None
        while attempt_inner <= max_retries:
            try:
                resp = requests.post(url, headers=headers_inner, json=answer_payload_inner, timeout=(20, 30))
                resp.raise_for_status()
                data = resp.json()
                choices = data.get("choices") or []
                if choices:
                    msg_inner = choices[0].get("message", {}).get("content")
                else:
                    msg_inner = None
            except Exception:
                msg_inner = None
            if not msg_inner:
                return
            ok_inner, why_inner = local_validate(msg_inner, faq_source_text)
            if ok_inner:
                final_msg_inner = msg_inner
                break
            attempt_inner += 1
            if attempt_inner > max_retries:
                break
            fix_note_inner = f"Please regenerate the answer and fix the following: {why_inner}" if why_inner else "Please regenerate the answer to match the required format."
            answer_payload_inner["messages"][1]["content"] = f"Question: {text_arg}\nProvide a concise answer based only on the FAQ. {fix_note_inner}"
        if not final_msg_inner:
            return
        client_arg.chat_postMessage(channel=channel_arg, text=final_msg_inner, thread_ts=ts_arg)
    except Exception:
        try:
            logger_arg.error("message processing error")
        except Exception:
            pass
        return
@app.event("message")
def handle_message_events(body, event, client, logger):
    if event.get("subtype") is not None:
        return
    if event.get("bot_id"):
        return
    if event.get("thread_ts"):
        return
    channel = event.get("channel")
    ts = event.get("ts")
    text = event.get("text")
    if not (channel and ts and text):
        return
    if listen_channels and channel not in listen_channels:
        return
    try:
        executor.submit(process_message, channel, ts, text, client, logger)
    except Exception:
        pass
    return
if __name__ == "__main__":
    handler = SocketModeHandler(app, app_token)
    handler.start()
